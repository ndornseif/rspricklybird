/// Pricklybird wordlist mapping each byte value to a word.
pub const WORDLIST: [&str; 256] = [
    "acid", "also", "anti", "arch", "area", "atom", "aunt", "baby", "back", "ball", "bang", "bare",
    "barn", "beef", "beep", "beer", "best", "beta", "blob", "blow", "boom", "boss", "bush", "call",
    "calm", "card", "cars", "cash", "clay", "coma", "cook", "core", "crab", "crop", "damp", "dark",
    "dash", "data", "dawn", "deaf", "deal", "deer", "deny", "dice", "disc", "dogs", "draw", "drug",
    "drum", "dust", "east", "easy", "eggs", "else", "epic", "etch", "ever", "evil", "exam", "face",
    "fact", "fawn", "film", "fish", "flag", "flaw", "flea", "flux", "food", "four", "full", "funk",
    "fury", "fuzz", "gain", "game", "gang", "gasp", "gear", "germ", "gift", "girl", "glow", "gold",
    "grab", "guts", "hair", "half", "hand", "harm", "hazy", "help", "herb", "hero", "high", "hill",
    "hiss", "horn", "hurt", "husk", "hype", "icon", "idea", "idle", "indy", "info", "iris", "itch",
    "item", "jade", "jail", "jaws", "join", "jump", "jury", "just", "kale", "keen", "keto", "kick",
    "king", "kiss", "kiwi", "knob", "lady", "lake", "lamp", "last", "leaf", "lens", "liar", "lion",
    "logo", "long", "lord", "luck", "lush", "mage", "mail", "many", "mars", "math", "memo", "menu",
    "meta", "mild", "mini", "moon", "must", "nail", "name", "navy", "neck", "need", "next", "noon",
    "norm", "nuts", "oath", "once", "orca", "oval", "over", "page", "paid", "palm", "path", "pawn",
    "ping", "pins", "play", "pool", "poor", "port", "puff", "pump", "quit", "race", "raid", "rain",
    "ramp", "rash", "rats", "rear", "redo", "reef", "ring", "risk", "room", "ruby", "rust", "safe",
    "sail", "salt", "sand", "scar", "ship", "sick", "sign", "sing", "slab", "slow", "soda", "solo",
    "stay", "surf", "swim", "taco", "talk", "taxi", "team", "tech", "text", "tiny", "tips", "toad",
    "tofu", "tomb", "tool", "tour", "trap", "tuna", "turf", "twig", "twin", "type", "ugly", "undo",
    "urge", "user", "very", "veto", "vial", "visa", "void", "volt", "vote", "walk", "wall", "warn",
    "warp", "wash", "wear", "west", "wind", "wing", "wire", "wolf", "worm", "yank", "yard", "yeah",
    "yell", "yoga", "zeus", "zone",
];

/// Wordlist with words represented as four byte arrays of UTF-8, ASCII compatible in this case.
pub const BYTE_WORDLIST: [[u8; 4]; 256] = convert_wordlist_to_bytes(&WORDLIST);

/// Take wordlist from string form to UTF-8 byte array form.
const fn convert_wordlist_to_bytes(wordlist: &[&str; 256]) -> [[u8; 4]; 256] {
    let mut result = [[0_u8; 4]; 256];

    let mut i = 0;
    while i < wordlist.len() {
        let word = wordlist[i];
        assert!(word.len() == 4, "Word must be exactly 4 bytes long.");

        let bytes = word.as_bytes();
        result[i] = [bytes[0], bytes[1], bytes[2], bytes[3]];
        i += 1;
    }
    result
}

/// Perfect hash function to index the `HASH_TABLE`.
///
/// Utilizes the fact that all words in the wordlist have unique first, last letter pairs.
/// Letters are expected to be the ASCII characters `a-z` in lowercase.
#[must_use]
pub const fn word_hash(word_first_letter: u8, word_last_letter: u8) -> usize {
    if word_first_letter.wrapping_sub(b'a') >= 26 {
        return 0;
    }
    if word_last_letter.wrapping_sub(b'a') >= 26 {
        return 0;
    }
    (word_first_letter - b'a') as usize + (word_last_letter - b'a') as usize * 26
}

/// The highest hash value generated by `word_hash` is 656 for words in the wordlist,
/// but with incorrect input where the first and last letter are `z`,
/// the value might reach 26 ** 2 - 1 = 675.
/// So we make the table 676 entries long to prevent out of bounds errors.
const HASH_TABLE_SIZE: usize = 676;

/// Generate hash table by calculating hash for every word and populating
/// the hash table position with that words byte value.
#[allow(clippy::cast_possible_truncation)]
const fn generate_hash_table(byte_wordlist: &[[u8; 4]; 256]) -> [u8; HASH_TABLE_SIZE] {
    let mut result = [0_u8; HASH_TABLE_SIZE];

    let mut i = 0;
    while i < byte_wordlist.len() {
        let hash_index = word_hash(byte_wordlist[i][0], byte_wordlist[i][3]);
        result[hash_index] = i as u8;
        i += 1;
    }
    result
}

/// Hash table indexed by giving the `word_hash` function the words first and last letter.
/// Contains the matching byte value.
pub const HASH_TABLE: [u8; HASH_TABLE_SIZE] = generate_hash_table(&BYTE_WORDLIST);

/// Polynominal used in CRC-8 calculation.
const CRC8_POLY: u8 = 0x1D;
/// Number of different possible values in a byte.
const N_BYTES: usize = 1 << u8::BITS;

/// Precomputes `CRC8_TABLE` to speed up CRC-8 calculations.
#[allow(clippy::cast_possible_truncation)]
const fn generate_crc_table(polynominal: u8) -> [u8; N_BYTES] {
    let mut table = [0_u8; N_BYTES];
    let mut i = 0;

    while i < N_BYTES {
        let mut crc = i as u8;
        let mut j = 0;

        while j < 8 {
            if crc & 0x80 != 0 {
                crc = (crc << 1) ^ polynominal;
            } else {
                crc <<= 1;
            }
            j += 1;
        }

        table[i] = crc;
        i += 1;
    }
    table
}

/// Table of CRC8 values for all possible bytes, allows fast calculation of CRC.
pub const CRC8_TABLE: [u8; N_BYTES] = generate_crc_table(CRC8_POLY);
